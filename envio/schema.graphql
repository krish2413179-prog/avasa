# ğŸ† Real-Time Financial Engine Schema
# Transforms raw blockchain events into meaningful financial intelligence

# ===== USER INTELLIGENCE =====
type User @entity {
  id: ID! # User wallet address
  
  # ğŸ§  Computed Intelligence Fields
  creditScore: Int! # Gamified score based on payment history
  totalRentPaid: BigInt! # Total USDC paid across all properties
  totalEquityEarned: BigInt! # Total property equity accumulated
  activeStreams: Int! # Number of active recurring payments
  
  # ğŸ“Š Performance Metrics
  onTimePayments: Int! # Successful payments made on time
  latePayments: Int! # Payments that were delayed
  cancelledStreams: Int! # Number of cancelled payment streams
  averagePaymentAmount: BigInt! # Average payment size
  
  # ğŸ  Property Portfolio
  propertiesOwned: [PropertyOwnership!]! @derivedFrom(field: "user")
  paymentSchedules: [PaymentSchedule!]! @derivedFrom(field: "payer")
  
  # â° Timestamps
  firstPaymentDate: BigInt # When user made their first payment
  lastPaymentDate: BigInt # Most recent payment
  createdAt: BigInt!
  updatedAt: BigInt!
}

# ===== PROPERTY INTELLIGENCE =====
type Property @entity {
  id: ID! # Property contract address
  
  # ğŸ“ Property Details
  name: String!
  location: String!
  propertyType: PropertyType!
  contractAddress: String!
  
  # ğŸ’° Financial Performance
  totalRevenue: BigInt! # Total USDC collected from this property
  totalInvestors: Int! # Number of unique investors
  occupancyRate: Float! # Percentage of units/shares occupied
  averageRentPerUnit: BigInt! # Average rent per unit/share
  
  # ğŸ“ˆ Performance Metrics
  monthlyRevenue: BigInt! # Revenue in the last 30 days
  revenueGrowthRate: Float! # Month-over-month growth
  investorRetentionRate: Float! # Percentage of investors who stay
  
  # ğŸ  Ownership Tracking
  totalShares: BigInt! # Total shares available
  sharesOwned: BigInt! # Total shares currently owned by investors
  sharePrice: BigInt! # Current price per share
  
  # ğŸ‘¥ Relationships
  owners: [PropertyOwnership!]! @derivedFrom(field: "property")
  paymentSchedules: [PaymentSchedule!]! @derivedFrom(field: "property")
  
  # â° Timestamps
  createdAt: BigInt!
  updatedAt: BigInt!
}

enum PropertyType {
  RESIDENTIAL
  COMMERCIAL
  INDUSTRIAL
  HOSPITALITY
  MIXED_USE
}

# ===== OWNERSHIP INTELLIGENCE =====
type PropertyOwnership @entity {
  id: ID! # user_address + property_address
  
  user: User!
  property: Property!
  
  # ğŸ“Š Ownership Details
  sharesOwned: BigInt! # Number of shares owned
  ownershipPercentage: Float! # Percentage of total property owned
  totalInvested: BigInt! # Total USDC invested in this property
  currentEquityValue: BigInt! # Current value of ownership
  
  # ğŸ“ˆ Performance Tracking
  unrealizedGains: BigInt! # Profit/loss on investment
  yieldEarned: BigInt! # Total yield/rent received
  averageMonthlyYield: BigInt! # Average monthly yield
  
  # â° Investment Timeline
  firstInvestmentDate: BigInt!
  lastInvestmentDate: BigInt!
  createdAt: BigInt!
  updatedAt: BigInt!
}

# ===== PAYMENT SCHEDULE INTELLIGENCE =====
type PaymentSchedule @entity {
  id: ID! # Schedule ID from contract
  
  # ğŸ‘¥ Participants
  payer: User!
  recipient: String! # Recipient address
  property: Property # Associated property (if applicable)
  
  # ğŸ’° Payment Details
  amount: BigInt! # Payment amount per execution
  interval: BigInt! # Interval in seconds
  maxExecutions: Int! # Maximum number of executions
  executionsLeft: Int! # Remaining executions
  
  # ğŸ“Š Status & Performance
  isActive: Boolean!
  totalExecuted: Int! # Number of successful executions
  totalAmountPaid: BigInt! # Total USDC paid through this schedule
  
  # â° Timing
  nextPaymentDue: BigInt! # When next payment is due
  createdAt: BigInt!
  lastExecutedAt: BigInt
  
  # ğŸ”— Relationships
  executions: [PaymentExecution!]! @derivedFrom(field: "schedule")
}

# ===== PAYMENT EXECUTION INTELLIGENCE =====
type PaymentExecution @entity {
  id: ID! # Transaction hash + log index
  
  schedule: PaymentSchedule!
  
  # ğŸ’° Execution Details
  amount: BigInt!
  executorReward: BigInt!
  executor: String! # Address of executor
  
  # ğŸ“Š Performance Metrics
  gasUsed: BigInt!
  gasPrice: BigInt!
  executionDelay: BigInt! # How late was this payment (0 = on time)
  
  # ğŸ”— Transaction Details
  transactionHash: String!
  blockNumber: BigInt!
  timestamp: BigInt!
}

# ===== GLOBAL PROTOCOL INTELLIGENCE =====
type ProtocolStats @entity {
  id: ID! # Always "global"
  
  # ğŸŒ Global Volume Metrics
  totalVolumeStreaming: BigInt! # Total USDC currently being streamed
  totalVolumeAllTime: BigInt! # All-time volume processed
  totalExecutions: BigInt! # Total number of payment executions
  
  # ğŸ‘¥ User Metrics
  totalUsers: Int! # Total number of users
  activeUsers: Int! # Users with active streams
  newUsersToday: Int! # New users in last 24 hours
  
  # ğŸ  Property Metrics
  totalProperties: Int! # Total number of properties
  totalPropertyValue: BigInt! # Combined value of all properties
  averageOccupancyRate: Float! # Average occupancy across all properties
  
  # ğŸ“ˆ Performance Metrics
  averageCreditScore: Float! # Average user credit score
  totalEquityGenerated: BigInt! # Total equity generated for users
  protocolRevenue: BigInt! # Total protocol fees collected
  
  # â° Time-based Metrics
  dailyVolume: BigInt! # Volume in last 24 hours
  weeklyVolume: BigInt! # Volume in last 7 days
  monthlyVolume: BigInt! # Volume in last 30 days
  
  # ğŸ”„ Real-time Status
  lastUpdated: BigInt!
}

# ===== REAL-TIME EVENTS =====
type StreamCreated @entity {
  id: ID! # Transaction hash + log index
  
  user: User!
  property: Property
  schedule: PaymentSchedule!
  
  amount: BigInt!
  interval: BigInt!
  maxExecutions: Int!
  
  transactionHash: String!
  blockNumber: BigInt!
  timestamp: BigInt!
}

type StreamExecuted @entity {
  id: ID! # Transaction hash + log index
  
  user: User!
  property: Property
  execution: PaymentExecution!
  
  amount: BigInt!
  newEquityEarned: BigInt! # Equity earned from this payment
  newCreditScore: Int! # Updated credit score
  
  transactionHash: String!
  blockNumber: BigInt!
  timestamp: BigInt!
}

type StreamCancelled @entity {
  id: ID! # Transaction hash + log index
  
  user: User!
  property: Property
  schedule: PaymentSchedule!
  
  reason: String # Cancellation reason
  amountPaidBeforeCancellation: BigInt!
  
  transactionHash: String!
  blockNumber: BigInt!
  timestamp: BigInt!
}

# ===== ANALYTICS & INSIGHTS =====
type DailyStats @entity {
  id: ID! # Date in YYYY-MM-DD format
  
  date: String!
  
  # ğŸ“Š Daily Metrics
  totalVolume: BigInt!
  totalExecutions: Int!
  newUsers: Int!
  activeUsers: Int!
  
  # ğŸ  Property Performance
  bestPerformingProperty: String! # Property with highest volume
  worstPerformingProperty: String! # Property with lowest volume
  
  # ğŸ’° Financial Metrics
  totalEquityGenerated: BigInt!
  averagePaymentSize: BigInt!
  protocolFees: BigInt!
  
  timestamp: BigInt!
}

type UserCreditHistory @entity {
  id: ID! # user_address + timestamp
  
  user: User!
  
  # ğŸ“Š Credit Score Evolution
  creditScore: Int!
  scoreChange: Int! # Change from previous score
  reason: String! # Why score changed
  
  # ğŸ“ˆ Performance Context
  totalPayments: Int! # Total payments at this point
  onTimePaymentRate: Float! # Percentage of on-time payments
  
  timestamp: BigInt!
}

# ===== PROPERTY PERFORMANCE TRACKING =====
type PropertyPerformance @entity {
  id: ID! # property_address + month (YYYY-MM)
  
  property: Property!
  month: String! # YYYY-MM format
  
  # ğŸ“Š Monthly Performance
  monthlyRevenue: BigInt!
  monthlyInvestors: Int!
  occupancyRate: Float!
  
  # ğŸ“ˆ Growth Metrics
  revenueGrowth: Float! # Compared to previous month
  investorGrowth: Float! # Investor count growth
  
  # ğŸ† Rankings
  revenueRank: Int! # Rank among all properties this month
  growthRank: Int! # Growth rank among all properties
  
  timestamp: BigInt!
}